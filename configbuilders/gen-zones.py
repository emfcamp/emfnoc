#!/usr/bin/python

#
# generate zone files from google spreadsheet
#
# Updated by JasperW to handle DNSSEC
# Updated by DavidC for 2014 spreadsheet format and more automation
#

import ipaddr
import time
import string, re
import os, pprint, ConfigParser, argparse
import shutil, sys, getpass

from subprocess import Popen, PIPE
from nocsheet import login, get_worksheets, get_worksheet_data
from nbh import NetboxHelper

codenamepos = 0

def ip6_arpa(octets, therange):
  out = ""
  for i in therange:
    if out != "":
      out = "." + out
    out = "%x.%x" % (ord(octets[i]) & 0xf, ord(octets[i]) >> 4) + out
  return out

def reverse_zone(address):
  octets = address.packed
  if isinstance(address, ipaddr._BaseV4):
    return "%s.%s.%s.in-addr.arpa" % (ord(octets[2]), ord(octets[1]), ord(octets[0]))
  elif isinstance(address, ipaddr._BaseV6):
    # it's a /32, so we want bytes 0-3 (nibbles 0-7)
    return ip6_arpa(octets, range(0, 4)) + ".ip6.arpa"

#x"c.8.0.0.8.f.7.0.1.0.0.2.ip6.arpa"
#x = ipaddr.IPAddress("2001:7f8:8c:57::11")
#print reverse_zone(x)
#print ip6_arpa(x.packed, range(6,16)) # it's a /48 so we want bytes 6-15
#exit()

def add_record(zonename, record):
  if zonename not in zones.keys():
    zones[zonename] = []
  zones[zonename].append(record)

def add_ipv4_host(hostname, fwd_zonename, ipv4, forward_only, reverse_only):
  if not reverse_only:
    #v4 forward
    record = "%s\tIN\tA\t%s" % (hostname, ipv4.compressed)
    add_record(fwd_zonename, record)

    if hostname in sshfps:
      for r in sshfps[hostname]:
        add_record(fwd_zonename, r)

  if forward_only:
    return

  #v4 reverse
  rev4_zonename = reverse_zone(ipv4)

  #remove any existing reverse if it exists
  if rev4_zonename in zones.keys():
    for record in zones[rev4_zonename]:
      if record.startswith("%s\tIN\tPTR\t" % (ord(ipv4.packed[3]))):
        zones[rev4_zonename].remove(record)
        break

  record = "%s\tIN\tPTR\t%s.%s." % (ord(ipv4.packed[3]), hostname, fwd_zonename)
  add_record(rev4_zonename, record)

def add_ipv6_host(hostname, fwd_zonename, ipv6, forward_only, reverse_only):
  if not reverse_only:
    #v6 forward
    record = "%s\tIN\tAAAA\t%s" % (hostname, ipv6.compressed)
    add_record(fwd_zonename, record)

  if forward_only:
    return

  #v6 reverse
  rev6_zonename = reverse_zone(ipv6)
  rev6_hostname = ip6_arpa(ipv6.packed, range(4,16)) # it's a /32 so we want bytes 4-15

  record = "%s\tIN\tPTR\t%s.%s." % (rev6_hostname, hostname, fwd_zonename)
  add_record(rev6_zonename, record)

def pretty_host(zonename, ipv4):
  if (zonename == "emf.camp"):
    octets = ipv4.packed
    return "host-%s-%s-%s-%s" % (ord(octets[0]), ord(octets[1]), ord(octets[2]), ord(octets[3]))
  else:
    global codenamepos
    if (codenamepos % len(codenames) == codenamepos / len(codenames)):
      codenamepos += 1
    code1 = codenamepos / len(codenames)
    code2 = codenamepos % len(codenames)
    if code1 >= len(codenames):
      print "RUN OUT OF CODENAMES AT POS %d" % codenamepos
      exit(1)

    codename1 = codenames[code1]["Codename"].strip().replace(" ", "")
    codename2 = codenames[code2]["Codename"].strip().replace(" ", "")
    codenamepos += 1
    return codename1 + "-" + codename2

def is_zone_signed(zone):
  if os.path.isdir("/etc/bind/signed-zones/%s" % zone):
    return True
  else:
    return False

def live_zone_file(zone):
#  /etc/bind/signed-zones/emf.camp
  if is_zone_signed(zone):
    return "/etc/bind/signed-zones/%s/zone.db" % zone
  else:
    return "/etc/bind/master/%s" % zone

def writezone(domainname, serial, entries, tempfile):
  if os.path.exists(tempfile) == True:
    os.remove(tempfile)
  f = open(tempfile, "w")
  f.write("\n")
  f.write("; zone file built by gen-zones.py from EMF NOC Google Spreadsheet\n")
  f.write("; %s.\n" % (domainname))
  f.write(";\n")
  f.write("; DO NOT EDIT THIS FILE!\n")
  f.write("; This file is automatically generated and changes will be lost next time it is built.\n")
  f.write("\n")
  f.write("$TTL    1h\n")
  f.write("$ORIGIN %s.\n" % (domainname))
  f.write("@   IN  SOA ns1.emfcamp.org. noc.emfcamp.org. (\n")
  f.write("            %s ; serial\n" % (serial))
  f.write("            3H ; refresh\n")
  f.write("            15 ; retry\n")
  f.write("            1w ; expire\n")
  f.write("            3h ; minimum\n")
  f.write("        )\n")
  f.write("\n")
  f.write("      IN      NS  ns1.emfcamp.org.\n")
  if domainname == "emf.camp":
    f.write("      IN      NS  A.AUTHNS.BITFOLK.COM.\n")
    f.write("      IN      NS  B.AUTHNS.BITFOLK.COM.\n")
    f.write("      IN      NS  C.AUTHNS.BITFOLK.COM.\n")
  else:
    f.write("      IN      NS  auth1.ns.sargasso.net.\n")
    f.write("      IN      NS  auth2.ns.sargasso.net.\n")
    f.write("      IN      NS  auth3.ns.sargasso.net.\n")
  f.write("\n")
  for row in entries:
    f.write("%s\n" % (row))

  f.write("\n")
  f.write("; DO NOT EDIT THIS FILE!\n")
  f.write("; This file is automatically generated and changes will be lost next time it is built.\n")
  f.close()
  return

def checkzone(domain, file):
  checkcmd = "/usr/sbin/named-checkzone %s %s" % (domain,file)
  checkresult = os.popen(checkcmd).read()
  if checkresult.endswith("OK\n") == True:
    return True
  else:
    return False

def makezonelive(domain,file):
  if getpass.getuser() != "root":
    print "  - Cannot put zone live, must be run as root"
    return False
  livefile = live_zone_file(domain)
  shutil.copyfile(file, livefile)

  ret = True

  if is_zone_signed(domain):
    # append to end of file
    with open(livefile, "a") as f:
      f.write("\n$INCLUDE dnskey.db\n")
    return True
  else:
    ret = reloadzone(domain)

  return ret

def reloadzone(domain):
  # zkt pokes bind to reload the zone, so don't do it ourselves.
  if not is_zone_signed(domain):
    reloadcmd = "rndc reload %s" % (domain)
    process = os.popen(reloadcmd)
    reloadresult = process.read()
    ret = process.close()
    # should process ret a bit?
    if ret != None:
      print("reload failed? %s" % (str(ret),))
      print reloadresult
      return False
    else:
      return True
  else:
    return True

def get_sshfps():
  #
  # There is a way of getting puppet to grab the keys
  # from the hosts it manages and then generating the records
  # but this was quicker
  #
  fps = {}
  if not os.path.exists("sshfps"):
    print "no sshfps records"
    return fps

  fh = open("sshfps", "r")
  for line in fh:
    host = line.split()[0]
    if host not in fps:
      fps[host] = []
    fps[host].append(line.strip())
  fh.close()
  return fps

def get_serial(zonename):
  realzone = live_zone_file(zonename)
  if not os.path.exists(realzone):
    print "Can't open " + realzone + ", using default serial number"
    return int(time.time())
  zfh = open(realzone, "r")
  got = False

  zoneserial = None
  for line in zfh:
    if got:
      line = line.strip()
      line = line.split()[0]
      zoneserial = int(line)
      zoneserial += 1
      got = False
      break
    if re.search("SOA\s+ns1\.emfcamp\.org", line):
      got = True
  zfh.close()

  if zoneserial == None:
    print "Couldn't find serial for " + zonename + " - using default"
    return int(time.time())
  return zoneserial

def slugify(value):
  value = str(value)

  value = re.sub(r"[^\w\s-]", "-", value.lower())
  return re.sub(r"[-\s]+", "-", value).strip("-_")

def extract_zone(full_hostname):
  known_zones = ['emf.camp', 'gchq.org.uk', 'emfcamp.org']

def load_codenames(filename):
  with open(filename, 'rt') as codename_file:
    codenames = codename_file.read().split('\n')
    to_remove = []
    for idx, codename in enumerate(codenames):
      if not re.match(r'^[0-9A-Z\- ]+$', codename):
        to_remove.append(idx)
        print(f"Codename '{codename}' in position {idx} is not valid, removing")

    for idx in sorted(to_remove, reverse=True):
      del codenames[idx]

  return codenames

def get_addressing(helper):
  addressing = []

  all_ips = helper.netbox.ipam.ip_addresses.all()
  for ip in all_ips:
    address = {}
    if ip.family.value == 4:
      address['address'] = ipaddress.IPv4Interface(ip.address).ip
    elif ip.family.value == 6:
      address['address'] = ipaddress.IPv6Interface(ip.address).ip

    if ip.dns_name is not None:
      hostname, zone = extract_zone(ip.dns_name)
      address['hostname'] == hostname
      address['zone'] = zone

    elif ip.assigned_object is not None:
      interface = ip.assigned_object.name
      device = None
      if hasattr(ip.assigned_object, 'device'):
        device = ip.assigned_object.device.name
      else:
        device = ip.assigned_object.virtual_machine.name

      full_hostname = slugify()


if __name__ == "__main__":

  default_domain = "emf.camp"
  camper_subnet = ''

  helper = NetboxHelper.getInstance()

  parser = argparse.ArgumentParser(description='Generate zone files from NetBox data')
  parser.add_argument('--deploy', action='store_true',
                      help='deploy zone files after generating')
  parser.add_argument('--diff', action='store_true',
                      help='diff zone files against live versions after generating')

  args = parser.parse_args()

  if args.deploy and args.diff:
    print "only one of --deploy and --diff can be specified"
    raise SystemExit

  if not os.path.exists('out'):
    os.mkdir('out')
  if not os.path.exists('out/zones'):
    os.mkdir('out/zones')

  codenames = load_codenames('./codenames.txt')

  addressing = get_addressing(helper)


  #for x in range(0, 2560000):
  #  print pretty_host("gchq.org.uk", None)

  #sshfps = get_sshfps()
  zones = {}



  for row in addressing:
    if "Domain" in row:
      fwd_zonename = row["Domain"];
    else:
      fwd_zonename = default_domain

    # is it a host?
    if "Hostname" in row and "dns" in row and (row["dns"] == "y" or row["dns"] == "fwd" or row["dns"] == "rev"):
      hostname = row["Hostname"]
      if "Subdomain" in row:
        hostname += "." + row["Subdomain"]

      if "IPv4" in row:
        ipv4 = ipaddr.IPv4Address(row["IPv4"])
        add_ipv4_host(hostname, fwd_zonename, ipv4, (row["dns"] == "fwd"), (row["dns"] == "rev"))

      if "IPv6" in row:
        ipv6 = ipaddr.IPv6Address(row["IPv6"])
        add_ipv6_host(hostname, fwd_zonename, ipv6, (row["dns"] == "fwd"), (row["dns"] == "rev"))

    # is it a subnet with auto dns?
    elif "IPv4-Subnet" in row and "dns" in row and row["dns"] == "auto":
      subnet = ipaddr.IPv4Network(row["IPv4-Subnet"])
      # router entry
      if "VLAN" in row:
        vlan = row["VLAN"]
        add_ipv4_host("vlan" + vlan + ".ESNORE", "emf.camp", subnet.network + 1, False, False)
  #      if "IPv6" in row:
        ipv6 = ipaddr.IPv6Network(row["IPv6"])
        add_ipv6_host("vlan" + vlan + ".ESNORE", "emf.camp", ipv6.network + 1, False, False)

      # host entries
      for ipv4 in subnet.iterhosts():
        if ipv4 == subnet.network + 1: # first host is the gateway
          continue
        hostname = pretty_host(fwd_zonename, ipv4)
        if "Subdomain" in row:
          hostname += "." + row["Subdomain"]
        add_ipv4_host(hostname, fwd_zonename, ipv4, False, False)

    # is it a cname or other fixed record?
    elif "dns" in row and row["dns"] == "record":
      hostname = row["Hostname"]
      if "Subdomain" in row:
        hostname += "." + row["Subdomain"]
      add_record(fwd_zonename, hostname + "\t" + row["Description"])

    # if it's a Network with dns='y', we need to 'touch' all the reverse dns to make sure
    # every individual zone exists
    elif "Network" in row and "dns" in row and row["dns"] == "y":
      net = ipaddr.IPv4Network(row["Network"])
      for subnet in net.iter_subnets(new_prefix = 24):
        zonename = reverse_zone(subnet)
        if zonename not in zones.keys():
          zones[zonename] = []

#print "ZONES:"
#pprint.pprint(zones)

# write out zone files






  print "Generating zones"
  success = 0
  failed = 0
  for zonename in zones.keys():
    tempfile = "out/zones/%s" % (zonename)
    zoneserial = get_serial(zonename)
    print "* %s" % (zonename),
    writezone(zonename, zoneserial, zones[zonename], tempfile)
    if checkzone(zonename, tempfile) == True:
      print " ok"
      if args.deploy:
        ret = makezonelive(zonename, tempfile)
        if ret:
          success += 1
        else:
          failed += 1
      if args.diff:
        cmd = "diff -u %s %s" % (live_zone_file(zonename), tempfile)
        p = os.popen(cmd)
        out = p.read()
        ret = p.close()
        # no diff
        if ret == None:
          pass
        else:
          # some change
          z = """
  --- /etc/bind/master/223.216.151.in-addr.arpa	2018-08-30 18:08:01.787143282 +0000
  +++ out/zones/223.216.151.in-addr.arpa	2018-08-30 18:08:44.023682338 +0000
  @@ -8,7 +8,7 @@
  $TTL    1h
  $ORIGIN 223.216.151.in-addr.arpa.
  @   IN  SOA ns1.emfcamp.org. noc.emfcamp.org. (
  -            1469569893 ; serial
  +            1469569894 ; serial
              3H ; refresh
              15 ; retry
              1w ; expire

              """
          if ret == 256:
            q = out.split("\n")
            # don't print if just the serial changes
            if len(q) == 12 and q[6].endswith("serial") and q[7].endswith("serial"):
              pass
            else:
              print out
          else:
            print "error diffing %s" % (str(ret))
            print out
    else:
      print " VALIDATION FAILED: %s" % (tempfile)

  if args.deploy:
    print "Signing..."
    # tell zkt-signer that the zones have changed
    os.system("zkt-signer -v -r")

    print("zones deployed: %d successfully, %d failed" % (success, failed))
